name: Compromised scanners CI

on:
    pull_request:
        paths:
            - 'compromised-packages.txt'
    workflow_dispatch:
        inputs:
            ref:
                description: 'Branch or tag to run against (optional)'
                required: false
                default: ''
            entries:
                description: 'Number of entries from the list to use when building test fixtures (default 3)'
                required: false
                default: '3'

permissions:
    contents: read

env:
    N: ${{ github.event.inputs.entries || '3' }}

jobs:
    linux-bash:
        name: Bash scanner (Ubuntu)
        runs-on: ubuntu-latest
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Ensure Bash scanner is executable
              run: chmod +x ./compromised.sh

            - name: Generate test fixtures (+ export sample pkg/ver)
              shell: bash
              run: |
                  set -euo pipefail
                  LIST="compromised-packages.txt"
                  N="${N:-3}"

                  # Pick first N non-comment lines
                  mapfile -t entries < <(grep -E '^[[:space:]]*[^#[:space:]]' "$LIST" | head -n "$N")
                  if (( ${#entries[@]} == 0 )); then
                    echo "No entries found in compromised list" >&2
                    exit 1
                  fi

                  # Save the *first* entry as sample for later verification
                  first="${entries[0]}"
                  first_pkg="${first%%:*}"
                  first_ver_raw="${first#*:}"
                  # normalize: trim + take first token only (as beim Fixture-Bau)
                  first_ver="$(echo "$first_ver_raw" | xargs)"; first_ver="${first_ver%% *}"

                  {
                    echo "SAMPLE_PKG=$first_pkg"
                    echo "SAMPLE_VER_BAD=$first_ver"
                  } >> "$GITHUB_ENV"

                  # Helper to make a "far future" non-matching version
                  bump_ver() {
                    local v="$1"
                    if [[ "$v" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)(.*)?$ ]]; then
                      local major="${BASH_REMATCH[1]}" minor="${BASH_REMATCH[2]}" patch="${BASH_REMATCH[3]}" tail="${BASH_REMATCH[4]}"
                      echo "${major}.${minor}.$((patch+1000))${tail}"
                    else
                      echo "${v}.9999"
                    fi
                  }

                  # Also export the GOOD version we will use (bumped)
                  echo "SAMPLE_VER_GOOD=$(bump_ver "$first_ver")" >> "$GITHUB_ENV"

                  build_plock() {
                    local outfile="$1" mode="$2"
                    {
                      echo '{'
                      echo '  "name": "fixture-test",'
                      echo '  "version": "1.0.0",'
                      echo '  "lockfileVersion": 2,'
                      echo '  "requires": true,'
                      echo '  "packages": {'
                      echo '    "": { "name": "fixture-test", "version": "1.0.0" },'
                      for i in "${!entries[@]}"; do
                        l="${entries[$i]}"; pkg="${l%%:*}"; ver="${l#*:}"
                        ver="$(echo "$ver" | xargs)"; ver="${ver%% *}"
                        [[ "$mode" == "good" ]] && ver="$(bump_ver "$ver")"
                        printf '    "node_modules/%s": { "version": "%s" }' "$pkg" "$ver"
                        [[ $i -lt $((${#entries[@]}-1)) ]] && echo ',' || echo
                      done
                      echo '  },'
                      echo '  "dependencies": {'
                      for i in "${!entries[@]}"; do
                        l="${entries[$i]}"; pkg="${l%%:*}"; ver="${l#*:}"
                        ver="$(echo "$ver" | xargs)"; ver="${ver%% *}"
                        [[ "$mode" == "good" ]] && ver="$(bump_ver "$ver")"
                        printf '    "%s": { "version": "%s" }' "$pkg" "$ver"
                        [[ $i -lt $((${#entries[@]}-1)) ]] && echo ',' || echo
                      done
                      echo '  },'
                      echo '  "flat_versions": {'
                      for i in "${!entries[@]}"; do
                        l="${entries[$i]}"; pkg="${l%%:*}"; ver="${l#*:}"
                        ver="$(echo "$ver" | xargs)"; ver="${ver%% *}"
                        [[ "$mode" == "good" ]] && ver="$(bump_ver "$ver")"
                        printf '    "%s": "%s"' "$pkg" "$ver"
                        [[ $i -lt $((${#entries[@]}-1)) ]] && echo ',' || echo
                      done
                      echo '  }'
                      echo '}'
                    } > "$outfile"
                  }

                  build_plock package-lock.bad.json bad
                  build_plock package-lock.good.json good

            - name: Upload fixtures
              uses: actions/upload-artifact@v4
              with:
                  name: linux-fixtures
                  path: |
                      package-lock.bad.json
                      package-lock.good.json
                  if-no-files-found: error
                  retention-days: 14

            - name: Sanity check with jq/grep (BAD must contain SAMPLE_PKG@SAMPLE_VER_BAD)
              shell: bash
              run: |
                  set -euo pipefail
                  echo "Sample: $SAMPLE_PKG @ $SAMPLE_VER_BAD"

                  # 1) jq: check all three locations we generated
                  jq -e --arg p "$SAMPLE_PKG" --arg v "$SAMPLE_VER_BAD" '
                    (.flat_versions[$p] == $v)
                    or (.dependencies[$p].version == $v)
                    or (.packages["node_modules/" + $p].version == $v)
                  ' package-lock.bad.json >/dev/null || { echo "jq check failed: sample not present in BAD"; exit 1; }

                  # 2) grep fallback (flat_versions line)
                  if ! grep -E "\"$(printf '%s' "$SAMPLE_PKG" | sed 's/[][(){}.^$+*?|\\/]/\\&/g')\"[[:space:]]*:[[:space:]]*\"$(printf '%s' "$SAMPLE_VER_BAD" | sed 's/[][(){}.^$+*?|\\/]/\\&/g')\"" package-lock.bad.json >/dev/null; then
                    echo "grep check (flat_versions) did not see the sample in BAD"
                    # print helpful context
                    grep -n "\"$SAMPLE_PKG\"" package-lock.bad.json || true
                    exit 1
                  fi

            - name: Sanity check with jq/grep (GOOD must NOT contain SAMPLE_PKG@SAMPLE_VER_BAD)
              shell: bash
              run: |
                  set -euo pipefail
                  jq -e --arg p "$SAMPLE_PKG" --arg v "$SAMPLE_VER_BAD" '
                    (.flat_versions[$p] == $v)
                    or (.dependencies[$p].version == $v)
                    or (.packages["node_modules/" + $p].version == $v)
                  ' package-lock.good.json >/dev/null && { echo "Sample unexpectedly present in GOOD"; exit 1; } || true

            - name: Diagnose sizes & hashes after generation (Linux)
              shell: bash
              run: |
                  set -euo pipefail
                  for f in package-lock.bad.json package-lock.good.json; do
                    echo "== $f =="
                    wc -c < "$f" | awk '{print "bytes:",$1}'
                    md5sum "$f" | awk '{print "md5:",$1}'
                    sha256sum "$f" | awk '{print "sha256:",$1}'
                    printf 'file(1): '; file -b "$f" || true
                    echo
                  done

            - name: Run Bash scanner on BAD (force local list + verify)
              shell: bash
              env:
                  DEBUG: '1'
              run: |
                  set -euo pipefail
                  cp -f package-lock.bad.json package-lock.json

                  # Force local list (no network variability)
                  ./compromised.sh \
                    --list-url "file://$PWD/compromised-packages.txt" \
                    --cache-file "$PWD/compromised-packages.txt" \
                    --show-content --show-lines 10 \
                    2>&1 | tee bash_bad.txt

                  # Must find at least one match
                  total=$(grep -Eo '^Total: [0-9]+' bash_bad.txt | awk '{print $2}' | tail -n1 || echo "")
                  echo "Total matches in BAD fixture: ${total:-0}"
                  if [[ -z "${total:-}" || "${total}" -lt 1 ]]; then
                    echo "Expected at least one match with BAD fixture" >&2
                    exit 1
                  fi

            - name: Upload scanned BAD file (exact input)
              uses: actions/upload-artifact@v4
              with:
                  name: linux-scanned-bad-input
                  path: package-lock.json
                  if-no-files-found: error
                  retention-days: 14

            - name: Run Bash scanner on GOOD (force local list + verify)
              shell: bash
              run: |
                  set -euo pipefail
                  cp -f package-lock.good.json package-lock.json

                  ./compromised.sh \
                    --list-url "file://$PWD/compromised-packages.txt" \
                    --cache-file "$PWD/compromised-packages.txt" \
                    2>&1 | tee bash_good.txt

                  # Must be zero
                  if grep -q '^Total: [1-9][0-9]*' bash_good.txt; then
                    echo "Expected zero matches with GOOD fixture" >&2
                    exit 1
                  fi
                  grep -q 'No compromised packages found in lockfiles' bash_good.txt

            - name: Upload logs (Linux)
              uses: actions/upload-artifact@v4
              with:
                  name: linux-logs
                  path: |
                      bash_bad.txt
                      bash_good.txt
                  if-no-files-found: error
                  retention-days: 14

    windows-pwsh:
        name: PowerShell scanner (Windows)
        runs-on: windows-latest
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Generate test fixtures (+ export sample pkg/ver)
              shell: bash
              run: |
                  set -euo pipefail
                  LIST="compromised-packages.txt"
                  N="${N:-3}"
                  mapfile -t entries < <(grep -E '^[[:space:]]*[^#[:space:]]' "$LIST" | head -n "$N")
                  if (( ${#entries[@]} == 0 )); then
                    echo "No entries found in compromised list" >&2
                    exit 1
                  fi
                  first="${entries[0]}"
                  first_pkg="${first%%:*}"
                  first_ver_raw="${first#*:}"
                  first_ver="$(echo "$first_ver_raw" | xargs)"; first_ver="${first_ver%% *}"

                  {
                    echo "SAMPLE_PKG=$first_pkg"
                    echo "SAMPLE_VER_BAD=$first_ver"
                  } >> "$GITHUB_ENV"

                  bump_ver() {
                    local v="$1"
                    if [[ "$v" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)(.*)?$ ]]; then
                      local major="${BASH_REMATCH[1]}" minor="${BASH_REMATCH[2]}" patch="${BASH_REMATCH[3]}" tail="${BASH_REMATCH[4]}"
                      echo "${major}.${minor}.$((patch+1000))${tail}"
                    else
                      echo "${v}.9999"
                    fi
                  }
                  echo "SAMPLE_VER_GOOD=$(bump_ver "$first_ver")" >> "$GITHUB_ENV"

                  build_plock() {
                    local outfile="$1" mode="$2"
                    {
                      echo '{'
                      echo '  "name": "fixture-test",'
                      echo '  "version": "1.0.0",'
                      echo '  "lockfileVersion": 2,'
                      echo '  "requires": true,'
                      echo '  "packages": {'
                      echo '    "": { "name": "fixture-test", "version": "1.0.0" },'
                      for i in "${!entries[@]}"; do
                        l="${entries[$i]}"; pkg="${l%%:*}"; ver="${l#*:}"
                        ver="$(echo "$ver" | xargs)"; ver="${ver%% *}"
                        [[ "$mode" == "good" ]] && ver="$(bump_ver "$ver")"
                        printf '    "node_modules/%s": { "version": "%s" }' "$pkg" "$ver"
                        [[ $i -lt $((${#entries[@]}-1)) ]] && echo ',' || echo
                      done
                      echo '  },'
                      echo '  "dependencies": {'
                      for i in "${!entries[@]}"; do
                        l="${entries[$i]}"; pkg="${l%%:*}"; ver="${l#*:}"
                        ver="$(echo "$ver" | xargs)"; ver="${ver%% *}"
                        [[ "$mode" == "good" ]] && ver="$(bump_ver "$ver")"
                        printf '    "%s": { "version": "%s" }' "$pkg" "$ver"
                        [[ $i -lt $((${#entries[@]}-1)) ]] && echo ',' || echo
                      done
                      echo '  },'
                      echo '  "flat_versions": {'
                      for i in "${!entries[@]}"; do
                        l="${entries[$i]}"; pkg="${l%%:*}"; ver="${l#*:}"
                        ver="$(echo "$ver" | xargs)"; ver="${ver%% *}"
                        [[ "$mode" == "good" ]] && ver="$(bump_ver "$ver")"
                        printf '    "%s": "%s"' "$pkg" "$ver"
                        [[ $i -lt $((${#entries[@]}-1)) ]] && echo ',' || echo
                      done
                      echo '  }'
                      echo '}'
                    } > "$outfile"
                  }

                  build_plock package-lock.bad.json bad
                  build_plock package-lock.good.json good

            - name: Upload fixtures
              uses: actions/upload-artifact@v4
              with:
                  name: windows-fixtures
                  path: |
                      package-lock.bad.json
                      package-lock.good.json
                  if-no-files-found: error
                  retention-days: 14

            - name: Sanity check with jq (via Git Bash) — BAD contains sample
              shell: bash
              run: |
                  set -euo pipefail
                  jq -e --arg p "$SAMPLE_PKG" --arg v "$SAMPLE_VER_BAD" '
                    (.flat_versions[$p] == $v)
                    or (.dependencies[$p].version == $v)
                    or (.packages["node_modules/" + $p].version == $v)
                  ' package-lock.bad.json >/dev/null

            - name: Run PowerShell scanner on BAD (force local list)
              shell: pwsh
              run: |
                  Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
                  Copy-Item package-lock.bad.json package-lock.json -Force

                  # Alle Streams -> StdOut (fängt auch Write-Host ein)
                  $out = & .\compromised.ps1 `
                      -Cache "$PWD\compromised-packages.txt" `
                      -ListUrl "file:///$($PWD -replace '\\','/')/compromised-packages.txt" `
                      *>&1

                  # $out ist ein Objekt-Array; robust in String wandeln:
                  $text = ($out | ForEach-Object { $_ | Out-String }).TrimEnd()

                  # Optional: ins Artefakt schreiben
                  Set-Content -Path pwsh_bad.txt -Value $text

                  if ($text -match 'Total:\s+(\d+)\s+match\(es\)') {
                      $total = [int]$Matches[1]
                      "Parsed total: $total"
                      if ($total -lt 1) {
                        throw "Expected at least one match with BAD fixture (got $total)"
                      }
                  } else {
                      # Fallback: rohen Text zeigen
                      Write-Host $text
                      throw "Did not find a 'Total: N match(es)' line in BAD output"
                  }

            - name: Run PowerShell scanner on GOOD (force local list)
              shell: pwsh
              run: |
                  Copy-Item package-lock.good.json package-lock.json -Force

                  $out = & .\compromised.ps1 `
                      -Cache "$PWD\compromised-packages.txt" `
                      -ListUrl "file:///$($PWD -replace '\\','/')/compromised-packages.txt" `
                      *>&1

                  $text = ($out | ForEach-Object { $_ | Out-String }).TrimEnd()
                  Set-Content -Path pwsh_good.txt -Value $text

                  if ($text -match 'Total:\s+([1-9]\d*)\s+match\(es\)') {
                      Write-Host $text
                      throw "Expected zero matches with GOOD fixture"
                  }
                  if ($text -notmatch 'No compromised packages found in lockfiles') {
                      Write-Host $text
                      throw "Expected the 'No compromised packages found in lockfiles' message in GOOD output"
                  }

            - name: Upload logs (Windows)
              uses: actions/upload-artifact@v4
              with:
                  name: windows-logs
                  path: |
                      pwsh_bad.txt
                      pwsh_good.txt
                  if-no-files-found: error
                  retention-days: 14
